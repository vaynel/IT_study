# 데이터베이스 설계

---

## 데이터베이스 설계란?

> **데이터베이스 설계**는 비즈니스 요구사항을 분석하여 효율적이고 일관된 데이터베이스 구조를 만드는 과정입니다. 올바른 설계는 성능, 확장성, 유지보수성을 결정하는 핵심 요소입니다.

---

## 데이터베이스 설계 단계

### 1. 요구사항 분석
* 비즈니스 요구사항 파악
* 데이터 요구사항 수집
* 사용자 요구사항 분석
* 성능 요구사항 정의

### 2. 개념적 설계
* 엔티티 식별
* 속성 정의
* 관계 정의
* ERD (Entity Relationship Diagram) 작성

### 3. 논리적 설계
* 정규화 수행
* 테이블 구조 정의
* 관계 매핑
* 제약 조건 정의

### 4. 물리적 설계
* 데이터 타입 선택
* 인덱스 설계
* 파티셔닝 전략
* 저장 공간 계획

### 5. 구현 및 검증
* 스키마 생성
* 데이터 마이그레이션
* 성능 테스트
* 최적화

---

## ERD (Entity Relationship Diagram)

### 기본 요소

**엔티티 (Entity)**
* 데이터베이스에 저장할 대상
* 예: 사용자, 주문, 상품

**속성 (Attribute)**
* 엔티티의 특성
* 예: 사용자 이름, 이메일, 나이

**관계 (Relationship)**
* 엔티티 간의 연결
* 예: 사용자-주문 (1:N)

### 관계 타입

**일대일 (1:1)**
```
사용자 (1) ──── (1) 프로필
```

**일대다 (1:N)**
```
사용자 (1) ──── (N) 주문
```

**다대다 (N:M)**
```
학생 (N) ──── (M) 강의
```

---

## 정규화 (Normalization)

### 정규화의 목적
* 데이터 중복 제거
* 데이터 무결성 보장
* 저장 공간 절약
* 업데이트 이상 방지

### 정규화 단계

#### 1NF (First Normal Form)
* 각 컬럼은 원자값만 가짐
* 중복 행 없음

**비정규화 예시:**
```
주문ID | 고객명 | 상품목록
-------|--------|----------
1      | 홍길동 | 노트북, 마우스, 키보드
```

**1NF 적용:**
```
주문ID | 고객명 | 상품명
-------|--------|--------
1      | 홍길동 | 노트북
1      | 홍길동 | 마우스
1      | 홍길동 | 키보드
```

#### 2NF (Second Normal Form)
* 1NF 만족
* 부분 함수 종속 제거 (기본키의 일부에만 종속되는 속성 제거)

**예시:**
```
주문ID | 상품ID | 상품명 | 수량 | 가격
-------|--------|--------|------|-----
1      | P001   | 노트북 | 1    | 1000
```

**2NF 적용:**
```
주문상세 테이블:
주문ID | 상품ID | 수량
-------|--------|-----
1      | P001   | 1

상품 테이블:
상품ID | 상품명 | 가격
-------|--------|-----
P001   | 노트북 | 1000
```

#### 3NF (Third Normal Form)
* 2NF 만족
* 이행 함수 종속 제거 (기본키가 아닌 속성에 종속되는 속성 제거)

**예시:**
```
사원ID | 사원명 | 부서ID | 부서명 | 부서위치
-------|--------|--------|--------|----------
E001   | 홍길동 | D001   | 개발팀 | 서울
```

**3NF 적용:**
```
사원 테이블:
사원ID | 사원명 | 부서ID
-------|--------|--------
E001   | 홍길동 | D001

부서 테이블:
부서ID | 부서명 | 부서위치
-------|--------|----------
D001   | 개발팀 | 서울
```

#### BCNF (Boyce-Codd Normal Form)
* 3NF 만족
* 모든 결정자가 후보키

#### 4NF, 5NF
* 다중값 종속 제거
* 조인 종속 제거

---

## 반정규화 (Denormalization)

### 반정규화의 목적
* 읽기 성능 향상
* 복잡한 JOIN 제거
* 쿼리 단순화

### 반정규화 전략

**컬럼 중복**
```sql
-- 주문 테이블에 고객명 추가
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    customer_name VARCHAR(100),  -- 중복
    order_date DATE
);
```

**파생 컬럼**
```sql
-- 주문 총액을 미리 계산하여 저장
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    total_amount DECIMAL(10,2),  -- 파생 컬럼
    order_date DATE
);
```

**테이블 통합**
```sql
-- 자주 함께 조회되는 테이블 통합
CREATE TABLE user_profile (
    user_id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    profile_data JSON  -- 프로필 정보 통합
);
```

### 반정규화 고려사항
* 업데이트 비용 증가
* 데이터 일관성 관리
* 저장 공간 증가
* 트레이드오프 분석

---

## 인덱스 설계

### 인덱스의 목적
* 검색 성능 향상
* 정렬 성능 향상
* JOIN 성능 향상

### 인덱스 타입

**단일 컬럼 인덱스**
```sql
CREATE INDEX idx_email ON users(email);
```

**복합 인덱스**
```sql
CREATE INDEX idx_name_email ON users(username, email);
```

**고유 인덱스**
```sql
CREATE UNIQUE INDEX idx_unique_email ON users(email);
```

**부분 인덱스**
```sql
CREATE INDEX idx_active_users ON users(email) 
WHERE status = 'active';
```

### 인덱스 설계 원칙
* 자주 조회되는 컬럼
* WHERE 절에 자주 사용되는 컬럼
* JOIN에 사용되는 컬럼
* ORDER BY에 사용되는 컬럼
* 외래키 컬럼

### 인덱스 주의사항
* 인덱스는 저장 공간 사용
* INSERT/UPDATE/DELETE 성능 저하
* 너무 많은 인덱스는 오히려 성능 저하
* 불필요한 인덱스 제거

---

## 데이터 타입 선택

### 숫자 타입
* **INT**: 일반적인 정수
* **BIGINT**: 큰 정수
* **DECIMAL**: 정확한 소수점
* **FLOAT/DOUBLE**: 근사치 소수점

### 문자열 타입
* **VARCHAR**: 가변 길이 문자열
* **CHAR**: 고정 길이 문자열
* **TEXT**: 긴 텍스트

### 날짜/시간 타입
* **DATE**: 날짜만
* **TIME**: 시간만
* **DATETIME**: 날짜와 시간
* **TIMESTAMP**: 타임스탬프

### 기타 타입
* **BOOLEAN**: 불린 값
* **JSON/JSONB**: JSON 데이터
* **BLOB**: 바이너리 데이터

---

## 관계 설계

### 외래키 (Foreign Key)
```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    user_id INT,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### 참조 무결성 옵션
```sql
FOREIGN KEY (user_id) REFERENCES users(id)
ON DELETE CASCADE      -- 부모 삭제 시 자식도 삭제
ON UPDATE CASCADE      -- 부모 업데이트 시 자식도 업데이트
ON DELETE SET NULL     -- 부모 삭제 시 자식은 NULL
ON DELETE RESTRICT     -- 부모 삭제 방지
```

---

## 파티셔닝 (Partitioning)

### 파티셔닝의 목적
* 대용량 테이블 관리
* 쿼리 성능 향상
* 유지보수 용이

### 파티셔닝 타입

**범위 파티셔닝 (Range Partitioning)**
```sql
CREATE TABLE orders (
    order_id INT,
    order_date DATE,
    total DECIMAL(10,2)
) PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025)
);
```

**리스트 파티셔닝 (List Partitioning)**
```sql
CREATE TABLE users (
    user_id INT,
    region VARCHAR(50)
) PARTITION BY LIST (region) (
    PARTITION p_korea VALUES IN ('Seoul', 'Busan'),
    PARTITION p_usa VALUES IN ('NY', 'LA')
);
```

**해시 파티셔닝 (Hash Partitioning)**
```sql
CREATE TABLE products (
    product_id INT,
    name VARCHAR(100)
) PARTITION BY HASH (product_id) PARTITIONS 4;
```

---

## 데이터베이스 설계 모범 사례

### 1. 명확한 네이밍
* 일관된 네이밍 컨벤션
* 의미 있는 이름
* 약어 사용 최소화

### 2. 적절한 정규화
* 과도한 정규화 지양
* 성능과 정규화 균형
* 비즈니스 요구사항 고려

### 3. 인덱스 전략
* 접근 패턴 분석
* 적절한 인덱스 생성
* 정기적인 인덱스 검토

### 4. 확장성 고려
* 미래 요구사항 예측
* 수평 확장 가능한 설계
* 파티셔닝 전략 수립

### 5. 보안
* 최소 권한 원칙
* 민감 정보 암호화
* 접근 제어 설계

### 6. 문서화
* ERD 작성
* 데이터 딕셔너리
* 설계 의도 문서화

---

## 설계 도구

### ERD 도구
* **MySQL Workbench**: MySQL ERD 도구
* **pgAdmin**: PostgreSQL 관리 도구
* **dbdiagram.io**: 온라인 ERD 도구
* **Draw.io**: 다이어그램 도구
* **Lucidchart**: 클라우드 다이어그램 도구

### 데이터 모델링 도구
* **ERwin**: 엔터프라이즈 데이터 모델링
* **PowerDesigner**: 데이터베이스 설계 도구
* **Toad Data Modeler**: 데이터베이스 모델링

---

## 설계 검증

### 정규화 검증
* 정규화 단계 확인
* 데이터 중복 확인
* 함수 종속성 확인

### 성능 검증
* 쿼리 성능 테스트
* 인덱스 효과 확인
* 부하 테스트

### 무결성 검증
* 제약 조건 테스트
* 외래키 검증
* 데이터 검증

---

## 참고

* 데이터베이스 설계는 애플리케이션의 기초입니다
* 요구사항을 충분히 분석한 후 설계하세요
* 정규화와 성능 사이의 균형을 고려하세요
* 확장 가능한 설계를 고려하세요
* 정기적인 설계 검토와 개선이 필요합니다

