# Quartz 블로그 자동 배포 시스템 구축기 (Webhook)

## 1. 개요: 왜 Webhook인가?

일반적으로 Quartz는 로컬에서 빌드 후 GitHub Pages 등으로 배포하지만, 전용 미니 서버를 사용한다면 매번 서버에 접속해 `git pull`과 `build`를 수동으로 하는 것은 비효율적입니다.
**GitHub Webhook**을 사용하면:

* 로컬에서 글을 쓰고 `git push`만 하면 서버가 이를 감지합니다.
* 서버가 자동으로 최신 글을 가져와(Git Pull) 다시 빌드(Quartz Build)합니다.
* 즉, **글쓰기에만 집중할 수 있는 CI/CD 환경**이 구축됩니다.

---

## 2. 시스템 아키텍처

전체 흐름은 다음과 같습니다:

1. **Local**: 마크다운 작성 후 GitHub Push
2. **GitHub**: 설정된 Webhook을 통해 서버로 POST 요청 전송 (HMAC 서명 포함)
3. **Nginx**: 외부 443 요청을 받아 내부 5000번 포트(Webhook Server)로 전달
4. **Python 서버**: 서명 검증 후 `git pull` 및 `quartz build` 실행
5. **Quartz (Static)**: 빌드된 결과물을 8080번 포트로 서비스

---

## 3. 단계별 구축 과정

### 1단계: Webhook 수신용 Python 서버 구현

Flask를 이용해 GitHub의 신호를 처리하고 보안(Secret)을 검증하는 서버를 구축했습니다. 특히 **NVM 환경의 Node 경로 이슈**를 해결하기 위해 `env` 주입 로직을 포함했습니다.

```python
# /root/blog/webhook_server.py
import hmac, hashlib, subprocess, os
from flask import Flask, request, abort

app = Flask(__name__)

PROJECTS = {
    "IT_study": {
        "path": "/root/blog/content/IT_study",
        "secret": b"YOUR_SECRET_TOKEN",
        "build_cmd": "npx quartz build"
    }
}

NODE_BIN_PATH = "/root/.nvm/versions/node/v24.12.0/bin"

@app.route('/webhook', methods=['POST'])
def webhook():
    signature = request.headers.get('X-Hub-Signature-256')
    payload_body = request.get_data()
    data = request.json
    
    repo_name = data['repository']['name']
    config = PROJECTS[repo_name]

    # HMAC SHA256 서명 검증
    mac = hmac.new(config['secret'], msg=payload_body, digestmod=hashlib.sha256)
    if not hmac.compare_digest('sha256=' + mac.hexdigest(), signature):
        abort(403)

    # 실행 환경 PATH 설정
    env = os.environ.copy()
    env["PATH"] = f"{NODE_BIN_PATH}:{env.get('PATH', '')}"

    # 작업 실행
    subprocess.run(["git", "fetch", "--all"], cwd=config["path"], check=True)
    subprocess.run(["git", "reset", "--hard", "origin/main"], cwd=config["path"], check=True)
    subprocess.run(config["build_cmd"], shell=True, cwd="/root/blog", env=env, check=True)
    
    return "OK", 200

```

### 2단계: Nginx 역방향 프록시 설정

외부에서 들어오는 Webhook 신호를 내부 Flask 서버로 안전하게 전달하도록 설정했습니다.

```nginx
location /webhook {
    proxy_pass http://localhost:5000/webhook;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    # 중요: GitHub 서명 헤더를 Flask로 전달
    proxy_set_header X-Hub-Signature-256 $http_x_hub_signature_256;
}

```

---

## 4. 주요 트러블슈팅 (에러 사항)

### ⚠️ Issue 1: HTTP 400 Bad Request

* **현상**: Nginx 로그에 `The plain HTTP request was sent to HTTPS port` 에러 발생.
* **원인**: Cloudflare의 SSL 설정이 `Flexible`로 되어 있어 서버의 443 포트로 암호화되지 않은 HTTP 신호를 보냄.
* **해결**: Cloudflare SSL 모드를 **Full (Strict)**로 변경하고 Nginx에 `error_page 497` 설정을 추가함.

### ⚠️ Issue 2: Webhook URL 경로 불일치

* **현상**: GitHub 신호가 들어오는데 `POST /`로 들어와서 404 혹은 무반응 발생.
* **원인**: GitHub Webhook 설정의 Payload URL 끝에 `/webhook` 경로 누락.
* **해결**: URL을 `https://domain.com/webhook`으로 수정.

### ⚠️ Issue 3: `npx: command not found` (PATH 문제)

* **현상**: `git pull`은 성공하나 Quartz 빌드 시 Node/npx를 찾지 못함.
* **원인**: `systemd` 서비스는 사용자의 NVM 경로를 인식하지 못함.
* **해결**: Python 코드에서 `os.environ`을 통해 `NODE_BIN_PATH`를 명시적으로 주입하거나, 서비스 파일에 `Environment="PATH=..."`를 등록함.

---

## 5. 결과 및 기대효과

이제 모든 설정이 완료되어 다음과 같은 자동화가 가능해졌습니다.

1. `git push` 발생
2. 서버 로그에 `✅ 검증 성공: IT_study 업데이트 시작...` 출력
3. 자동으로 `Vite building...` 수행
4. 블로그 실시간 반영 완료!

---

**한 줄 평:** > "인프라 구축은 한 번의 고통이지만, 자동화는 영원한 평화를 가져다준다."

---